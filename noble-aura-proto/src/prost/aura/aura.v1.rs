// @generated
// This file is @generated by prost-build.
/// Paused is emitted whenever the module is paused.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Paused {
    /// account is the address of the account that paused the module.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
}
impl ::prost::Name for Paused {
    const NAME: &'static str = "Paused";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.Paused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.Paused".into()
    }
}
/// Unpaused is emitted whenever the module is unpaused.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Unpaused {
    /// account is the address of the account that unpaused the module.
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
}
impl ::prost::Name for Unpaused {
    const NAME: &'static str = "Unpaused";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.Unpaused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.Unpaused".into()
    }
}
/// OwnershipTransferStarted is emitted whenever an ownership transfer is started.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnershipTransferStarted {
    /// previous_owner is the address of the previous owner.
    #[prost(string, tag = "1")]
    pub previous_owner: ::prost::alloc::string::String,
    /// new_owner is the address of the new owner.
    #[prost(string, tag = "2")]
    pub new_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for OwnershipTransferStarted {
    const NAME: &'static str = "OwnershipTransferStarted";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.OwnershipTransferStarted".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.OwnershipTransferStarted".into()
    }
}
/// OwnershipTransferStarted is emitted whenever an ownership transfer is finalized.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnershipTransferred {
    /// previous_owner is the address of the previous owner.
    #[prost(string, tag = "1")]
    pub previous_owner: ::prost::alloc::string::String,
    /// new_owner is the address of the new owner.
    #[prost(string, tag = "2")]
    pub new_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for OwnershipTransferred {
    const NAME: &'static str = "OwnershipTransferred";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.OwnershipTransferred".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.OwnershipTransferred".into()
    }
}
/// BurnerAdded is emitted whenever a new burner is added.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BurnerAdded {
    /// address is the address of the burner.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// allowance is the allowance of the burner.
    #[prost(string, tag = "2")]
    pub allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for BurnerAdded {
    const NAME: &'static str = "BurnerAdded";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.BurnerAdded".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.BurnerAdded".into()
    }
}
/// BurnerRemoved is emitted whenever a burner is removed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BurnerRemoved {
    /// address is the address of the burner.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for BurnerRemoved {
    const NAME: &'static str = "BurnerRemoved";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.BurnerRemoved".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.BurnerRemoved".into()
    }
}
/// BurnerUpdated is emitted whenever a burner's allowance is set.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BurnerUpdated {
    /// address is the address of the burner.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// previous_allowance is the previous allowance of the burner.
    #[prost(string, tag = "2")]
    pub previous_allowance: ::prost::alloc::string::String,
    /// new_allowance is the new allowance of the burner.
    #[prost(string, tag = "3")]
    pub new_allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for BurnerUpdated {
    const NAME: &'static str = "BurnerUpdated";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.BurnerUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.BurnerUpdated".into()
    }
}
/// MinterAdded is emitted whenever a new minter is added.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinterAdded {
    /// address is the address of the minter.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// allowance is the allowance of the minter.
    #[prost(string, tag = "2")]
    pub allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for MinterAdded {
    const NAME: &'static str = "MinterAdded";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MinterAdded".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MinterAdded".into()
    }
}
/// MinterRemoved is emitted whenever a minter is removed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinterRemoved {
    /// address is the address of the minter.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for MinterRemoved {
    const NAME: &'static str = "MinterRemoved";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MinterRemoved".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MinterRemoved".into()
    }
}
/// MinterUpdated is emitted whenever a minter's allowance is set.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MinterUpdated {
    /// address is the address of the minter.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// previous_allowance is the previous allowance of the minter.
    #[prost(string, tag = "2")]
    pub previous_allowance: ::prost::alloc::string::String,
    /// new_allowance is the new allowance of the minter.
    #[prost(string, tag = "3")]
    pub new_allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for MinterUpdated {
    const NAME: &'static str = "MinterUpdated";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MinterUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MinterUpdated".into()
    }
}
/// PauserAdded is emitted whenever a new pauser is added.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauserAdded {
    /// address is the address of the pauser.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for PauserAdded {
    const NAME: &'static str = "PauserAdded";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.PauserAdded".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.PauserAdded".into()
    }
}
/// PauserRemoved is emitted whenever a pauser is removed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauserRemoved {
    /// address is the address of the pauser.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for PauserRemoved {
    const NAME: &'static str = "PauserRemoved";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.PauserRemoved".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.PauserRemoved".into()
    }
}
/// BlockedChannelAdded is emitted whenever a blocked channel is added.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockedChannelAdded {
    /// channel is the id of the blocked channel.
    #[prost(string, tag = "1")]
    pub channel: ::prost::alloc::string::String,
}
impl ::prost::Name for BlockedChannelAdded {
    const NAME: &'static str = "BlockedChannelAdded";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.BlockedChannelAdded".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.BlockedChannelAdded".into()
    }
}
/// BlockedChannelRemoved is emitted whenever a blocked channel is removed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlockedChannelRemoved {
    /// channel is the id of the blocked channel.
    #[prost(string, tag = "1")]
    pub channel: ::prost::alloc::string::String,
}
impl ::prost::Name for BlockedChannelRemoved {
    const NAME: &'static str = "BlockedChannelRemoved";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.BlockedChannelRemoved".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.BlockedChannelRemoved".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// blocklist_state is the genesis state of the blocklist submodule.
    #[prost(message, optional, tag = "1")]
    pub blocklist_state: ::core::option::Option<super::blocklist::v1::GenesisState>,
    /// paused is the paused state of this module.
    #[prost(bool, tag = "2")]
    pub paused: bool,
    /// owner is the address that can control this module.
    #[prost(string, tag = "3")]
    pub owner: ::prost::alloc::string::String,
    /// pending_owner is the address of the new owner during an ownership transfer.
    #[prost(string, tag = "4")]
    pub pending_owner: ::prost::alloc::string::String,
    /// burners is the list of addresses that can burn USDY.
    #[prost(message, repeated, tag = "5")]
    pub burners: ::prost::alloc::vec::Vec<Burner>,
    /// minters is the list of addresses that can mint USDY.
    #[prost(message, repeated, tag = "6")]
    pub minters: ::prost::alloc::vec::Vec<Minter>,
    /// pausers is the list of addresses that can pause USDY.
    #[prost(string, repeated, tag = "7")]
    pub pausers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// blocked_channels is the list of IBC channels where transfers are blocked.
    #[prost(string, repeated, tag = "8")]
    pub blocked_channels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.GenesisState".into()
    }
}
//

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Burner {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for Burner {
    const NAME: &'static str = "Burner";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.Burner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.Burner".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Minter {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for Minter {
    const NAME: &'static str = "Minter";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.Minter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.Minter".into()
    }
}
//

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryDenom {}
impl ::prost::Name for QueryDenom {
    const NAME: &'static str = "QueryDenom";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryDenom".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryDenom".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDenomResponse {
    #[prost(string, tag = "1")]
    pub denom: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryDenomResponse {
    const NAME: &'static str = "QueryDenomResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryDenomResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryDenomResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPaused {}
impl ::prost::Name for QueryPaused {
    const NAME: &'static str = "QueryPaused";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryPaused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryPaused".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPausedResponse {
    #[prost(bool, tag = "1")]
    pub paused: bool,
}
impl ::prost::Name for QueryPausedResponse {
    const NAME: &'static str = "QueryPausedResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryPausedResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryPausedResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryOwner {}
impl ::prost::Name for QueryOwner {
    const NAME: &'static str = "QueryOwner";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryOwner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryOwner".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOwnerResponse {
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pending_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryOwnerResponse {
    const NAME: &'static str = "QueryOwnerResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryOwnerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryOwnerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryBurners {}
impl ::prost::Name for QueryBurners {
    const NAME: &'static str = "QueryBurners";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryBurners".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryBurners".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBurnersResponse {
    #[prost(message, repeated, tag = "1")]
    pub burners: ::prost::alloc::vec::Vec<Burner>,
}
impl ::prost::Name for QueryBurnersResponse {
    const NAME: &'static str = "QueryBurnersResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryBurnersResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryBurnersResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryMinters {}
impl ::prost::Name for QueryMinters {
    const NAME: &'static str = "QueryMinters";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryMinters".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryMinters".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMintersResponse {
    #[prost(message, repeated, tag = "1")]
    pub minters: ::prost::alloc::vec::Vec<Minter>,
}
impl ::prost::Name for QueryMintersResponse {
    const NAME: &'static str = "QueryMintersResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryMintersResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryMintersResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPausers {}
impl ::prost::Name for QueryPausers {
    const NAME: &'static str = "QueryPausers";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryPausers".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryPausers".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPausersResponse {
    #[prost(string, repeated, tag = "1")]
    pub pausers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for QueryPausersResponse {
    const NAME: &'static str = "QueryPausersResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryPausersResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryPausersResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryBlockedChannels {}
impl ::prost::Name for QueryBlockedChannels {
    const NAME: &'static str = "QueryBlockedChannels";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryBlockedChannels".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryBlockedChannels".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryBlockedChannelsResponse {
    #[prost(string, repeated, tag = "1")]
    pub blocked_channels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for QueryBlockedChannelsResponse {
    const NAME: &'static str = "QueryBlockedChannelsResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.QueryBlockedChannelsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.QueryBlockedChannelsResponse".into()
    }
}
//

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgBurn {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgBurn {
    const NAME: &'static str = "MsgBurn";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgBurn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgBurn".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgBurnResponse {}
impl ::prost::Name for MsgBurnResponse {
    const NAME: &'static str = "MsgBurnResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgBurnResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgBurnResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgMint {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub to: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgMint {
    const NAME: &'static str = "MsgMint";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgMint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgMint".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgMintResponse {}
impl ::prost::Name for MsgMintResponse {
    const NAME: &'static str = "MsgMintResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgMintResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgMintResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgPause {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgPause {
    const NAME: &'static str = "MsgPause";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgPause".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgPause".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgPauseResponse {}
impl ::prost::Name for MsgPauseResponse {
    const NAME: &'static str = "MsgPauseResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgPauseResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgPauseResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUnpause {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUnpause {
    const NAME: &'static str = "MsgUnpause";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgUnpause".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgUnpause".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUnpauseResponse {}
impl ::prost::Name for MsgUnpauseResponse {
    const NAME: &'static str = "MsgUnpauseResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgUnpauseResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgUnpauseResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTransferOwnership {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgTransferOwnership {
    const NAME: &'static str = "MsgTransferOwnership";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgTransferOwnership".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgTransferOwnership".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgTransferOwnershipResponse {}
impl ::prost::Name for MsgTransferOwnershipResponse {
    const NAME: &'static str = "MsgTransferOwnershipResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgTransferOwnershipResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgTransferOwnershipResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAcceptOwnership {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgAcceptOwnership {
    const NAME: &'static str = "MsgAcceptOwnership";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAcceptOwnership".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAcceptOwnership".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAcceptOwnershipResponse {}
impl ::prost::Name for MsgAcceptOwnershipResponse {
    const NAME: &'static str = "MsgAcceptOwnershipResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAcceptOwnershipResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAcceptOwnershipResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddBurner {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub burner: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgAddBurner {
    const NAME: &'static str = "MsgAddBurner";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAddBurner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAddBurner".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAddBurnerResponse {}
impl ::prost::Name for MsgAddBurnerResponse {
    const NAME: &'static str = "MsgAddBurnerResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAddBurnerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAddBurnerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRemoveBurner {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub burner: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRemoveBurner {
    const NAME: &'static str = "MsgRemoveBurner";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgRemoveBurner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgRemoveBurner".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRemoveBurnerResponse {}
impl ::prost::Name for MsgRemoveBurnerResponse {
    const NAME: &'static str = "MsgRemoveBurnerResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgRemoveBurnerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgRemoveBurnerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetBurnerAllowance {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub burner: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSetBurnerAllowance {
    const NAME: &'static str = "MsgSetBurnerAllowance";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgSetBurnerAllowance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgSetBurnerAllowance".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetBurnerAllowanceResponse {}
impl ::prost::Name for MsgSetBurnerAllowanceResponse {
    const NAME: &'static str = "MsgSetBurnerAllowanceResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgSetBurnerAllowanceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgSetBurnerAllowanceResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddMinter {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub minter: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgAddMinter {
    const NAME: &'static str = "MsgAddMinter";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAddMinter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAddMinter".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAddMinterResponse {}
impl ::prost::Name for MsgAddMinterResponse {
    const NAME: &'static str = "MsgAddMinterResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAddMinterResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAddMinterResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRemoveMinter {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub minter: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRemoveMinter {
    const NAME: &'static str = "MsgRemoveMinter";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgRemoveMinter".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgRemoveMinter".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRemoveMinterResponse {}
impl ::prost::Name for MsgRemoveMinterResponse {
    const NAME: &'static str = "MsgRemoveMinterResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgRemoveMinterResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgRemoveMinterResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetMinterAllowance {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub minter: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub allowance: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSetMinterAllowance {
    const NAME: &'static str = "MsgSetMinterAllowance";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgSetMinterAllowance".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgSetMinterAllowance".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetMinterAllowanceResponse {}
impl ::prost::Name for MsgSetMinterAllowanceResponse {
    const NAME: &'static str = "MsgSetMinterAllowanceResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgSetMinterAllowanceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgSetMinterAllowanceResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddPauser {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pauser: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgAddPauser {
    const NAME: &'static str = "MsgAddPauser";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAddPauser".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAddPauser".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAddPauserResponse {}
impl ::prost::Name for MsgAddPauserResponse {
    const NAME: &'static str = "MsgAddPauserResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAddPauserResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAddPauserResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRemovePauser {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pauser: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRemovePauser {
    const NAME: &'static str = "MsgRemovePauser";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgRemovePauser".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgRemovePauser".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRemovePauserResponse {}
impl ::prost::Name for MsgRemovePauserResponse {
    const NAME: &'static str = "MsgRemovePauserResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgRemovePauserResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgRemovePauserResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddBlockedChannel {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub channel: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgAddBlockedChannel {
    const NAME: &'static str = "MsgAddBlockedChannel";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAddBlockedChannel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAddBlockedChannel".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAddBlockedChannelResponse {}
impl ::prost::Name for MsgAddBlockedChannelResponse {
    const NAME: &'static str = "MsgAddBlockedChannelResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgAddBlockedChannelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgAddBlockedChannelResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRemoveBlockedChannel {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub channel: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRemoveBlockedChannel {
    const NAME: &'static str = "MsgRemoveBlockedChannel";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgRemoveBlockedChannel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgRemoveBlockedChannel".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRemoveBlockedChannelResponse {}
impl ::prost::Name for MsgRemoveBlockedChannelResponse {
    const NAME: &'static str = "MsgRemoveBlockedChannelResponse";
    const PACKAGE: &'static str = "aura.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "aura.v1.MsgRemoveBlockedChannelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/aura.v1.MsgRemoveBlockedChannelResponse".into()
    }
}
include!("aura.v1.serde.rs");
include!("aura.v1.tonic.rs");
// @@protoc_insertion_point(module)
