// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reward {
    #[prost(int64, tag = "1")]
    pub index: i64,
    #[prost(string, tag = "2")]
    pub total: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rewards: ::prost::alloc::string::String,
}
impl ::prost::Name for Reward {
    const NAME: &'static str = "Reward";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.Reward".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.Reward".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(string, tag = "1")]
    pub principal: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub index: i64,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub time: ::core::option::Option<::tendermint_proto::google::protobuf::Timestamp>,
}
impl ::prost::Name for Position {
    const NAME: &'static str = "Position";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.Position".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.Position".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionEntry {
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "VaultType", tag = "2")]
    pub vault: i32,
    #[prost(string, tag = "3")]
    pub principal: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub index: i64,
    #[prost(string, tag = "5")]
    pub amount: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub time: ::core::option::Option<::tendermint_proto::google::protobuf::Timestamp>,
}
impl ::prost::Name for PositionEntry {
    const NAME: &'static str = "PositionEntry";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.PositionEntry".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.PositionEntry".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stats {
    #[prost(string, tag = "1")]
    pub flexible_total_principal: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub flexible_total_users: u64,
    #[prost(string, tag = "3")]
    pub flexible_total_distributed_rewards_principal: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub staked_total_principal: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub staked_total_users: u64,
}
impl ::prost::Name for Stats {
    const NAME: &'static str = "Stats";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.Stats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.Stats".into()
    }
}
/// buf:lint:ignore ENUM_VALUE_PREFIX
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VaultType {
    /// buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
    Unspecified = 0,
    Staked = 1,
    Flexible = 2,
}
impl VaultType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VaultType::Unspecified => "UNSPECIFIED",
            VaultType::Staked => "STAKED",
            VaultType::Flexible => "FLEXIBLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNSPECIFIED" => Some(Self::Unspecified),
            "STAKED" => Some(Self::Staked),
            "FLEXIBLE" => Some(Self::Flexible),
            _ => None,
        }
    }
}
/// buf:lint:ignore ENUM_VALUE_PREFIX
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PausedType {
    /// buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
    None = 0,
    Lock = 1,
    Unlock = 2,
    All = 3,
}
impl PausedType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PausedType::None => "NONE",
            PausedType::Lock => "LOCK",
            PausedType::Unlock => "UNLOCK",
            PausedType::All => "ALL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "LOCK" => Some(Self::Lock),
            "UNLOCK" => Some(Self::Unlock),
            "ALL" => Some(Self::All),
            _ => None,
        }
    }
}
/// GenesisState defines the genesis state of the Noble Dollar Vaults submodule.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// total_flexible_principal contains all the users positions inside Vaults.
    #[prost(message, repeated, tag = "2")]
    pub positions: ::prost::alloc::vec::Vec<PositionEntry>,
    /// rewards maps the rewards amounts by the index.
    #[prost(message, repeated, tag = "3")]
    pub rewards: ::prost::alloc::vec::Vec<Reward>,
    /// total_flexible_principal contains the total principal amount contained in the flexible Vault.
    #[prost(string, tag = "4")]
    pub total_flexible_principal: ::prost::alloc::string::String,
    /// paused represents the current pausing state of the Vaults.
    #[prost(enumeration = "PausedType", tag = "5")]
    pub paused: i32,
    /// stats contains the genesis statistics around the Noble Dollar Vaults.
    #[prost(message, optional, tag = "6")]
    pub stats: ::core::option::Option<Stats>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.GenesisState".into()
    }
}
/// PositionLocked is an event emitted when a user locks $USDN into a Vault.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionLocked {
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vault_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub index: i64,
    #[prost(string, tag = "4")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub principal: ::prost::alloc::string::String,
}
impl ::prost::Name for PositionLocked {
    const NAME: &'static str = "PositionLocked";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.PositionLocked".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.PositionLocked".into()
    }
}
/// PositionUnlocked is an event emitted when a user unlocks their $USDN from a Vault.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionUnlocked {
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vault_type: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub index: i64,
    #[prost(string, tag = "4")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub principal: ::prost::alloc::string::String,
}
impl ::prost::Name for PositionUnlocked {
    const NAME: &'static str = "PositionUnlocked";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.PositionUnlocked".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.PositionUnlocked".into()
    }
}
/// PausedStateUpdated is an event emitted when the module pause
/// state is changed.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PausedStateUpdated {
    #[prost(string, tag = "1")]
    pub paused: ::prost::alloc::string::String,
}
impl ::prost::Name for PausedStateUpdated {
    const NAME: &'static str = "PausedStateUpdated";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.PausedStateUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.PausedStateUpdated".into()
    }
}
/// RewardClaimed is an event emitted whenever a user claim their rewards.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RewardClaimed {
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
impl ::prost::Name for RewardClaimed {
    const NAME: &'static str = "RewardClaimed";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.RewardClaimed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.RewardClaimed".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPositionsByProvider {
    #[prost(string, tag = "1")]
    pub provider: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryPositionsByProvider {
    const NAME: &'static str = "QueryPositionsByProvider";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryPositionsByProvider".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryPositionsByProvider".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPositionsByProviderResponse {
    #[prost(message, repeated, tag = "1")]
    pub positions: ::prost::alloc::vec::Vec<PositionEntry>,
}
impl ::prost::Name for QueryPositionsByProviderResponse {
    const NAME: &'static str = "QueryPositionsByProviderResponse";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryPositionsByProviderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryPositionsByProviderResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPaused {}
impl ::prost::Name for QueryPaused {
    const NAME: &'static str = "QueryPaused";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryPaused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryPaused".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPausedResponse {
    #[prost(enumeration = "PausedType", tag = "1")]
    pub paused: i32,
}
impl ::prost::Name for QueryPausedResponse {
    const NAME: &'static str = "QueryPausedResponse";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryPausedResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryPausedResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPendingRewards {}
impl ::prost::Name for QueryPendingRewards {
    const NAME: &'static str = "QueryPendingRewards";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryPendingRewards".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryPendingRewards".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPendingRewardsResponse {
    #[prost(string, tag = "1")]
    pub pending_rewards: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryPendingRewardsResponse {
    const NAME: &'static str = "QueryPendingRewardsResponse";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryPendingRewardsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryPendingRewardsResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPendingRewardsByProvider {
    #[prost(string, tag = "1")]
    pub provider: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryPendingRewardsByProvider {
    const NAME: &'static str = "QueryPendingRewardsByProvider";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryPendingRewardsByProvider".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryPendingRewardsByProvider".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPendingRewardsByProviderResponse {
    #[prost(string, tag = "1")]
    pub pending_rewards: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryPendingRewardsByProviderResponse {
    const NAME: &'static str = "QueryPendingRewardsByProviderResponse";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryPendingRewardsByProviderResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryPendingRewardsByProviderResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryStats {}
impl ::prost::Name for QueryStats {
    const NAME: &'static str = "QueryStats";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryStats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryStats".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStatsResponse {
    #[prost(string, tag = "1")]
    pub flexible_total_principal: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub flexible_total_users: u64,
    #[prost(string, tag = "3")]
    pub flexible_total_distributed_rewards_principal: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub staked_total_principal: ::prost::alloc::string::String,
    #[prost(uint64, tag = "5")]
    pub staked_total_users: u64,
}
impl ::prost::Name for QueryStatsResponse {
    const NAME: &'static str = "QueryStatsResponse";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.QueryStatsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.QueryStatsResponse".into()
    }
}
/// MsgLock is a message holders of the Noble Dollar can use to lock their $USDN into a Vault to earn rewards.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgLock {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(enumeration = "VaultType", tag = "2")]
    pub vault: i32,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgLock {
    const NAME: &'static str = "MsgLock";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.MsgLock".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.MsgLock".into()
    }
}
/// MsgLockResponse is the response of the Lock message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgLockResponse {}
impl ::prost::Name for MsgLockResponse {
    const NAME: &'static str = "MsgLockResponse";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.MsgLockResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.MsgLockResponse".into()
    }
}
/// MsgUnlock is a message that allows holders of the Noble Dollar to unlock their $USDN from a Vault, releasing their funds and claiming any available rewards.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUnlock {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(enumeration = "VaultType", tag = "2")]
    pub vault: i32,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUnlock {
    const NAME: &'static str = "MsgUnlock";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.MsgUnlock".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.MsgUnlock".into()
    }
}
/// MsgLockResponse is the response of the Unlock message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUnlockResponse {}
impl ::prost::Name for MsgUnlockResponse {
    const NAME: &'static str = "MsgUnlockResponse";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.MsgUnlockResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.MsgUnlockResponse".into()
    }
}
/// MsgSetPausedState allows the authority to configure the Noble Dollar Vault paused state, enabling or disabling Lock and Unlock actions.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetPausedState {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(enumeration = "PausedType", tag = "2")]
    pub paused: i32,
}
impl ::prost::Name for MsgSetPausedState {
    const NAME: &'static str = "MsgSetPausedState";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.MsgSetPausedState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.MsgSetPausedState".into()
    }
}
/// MsgSetPausedStateResponse is the response of the SetPausedState message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetPausedStateResponse {}
impl ::prost::Name for MsgSetPausedStateResponse {
    const NAME: &'static str = "MsgSetPausedStateResponse";
    const PACKAGE: &'static str = "noble.dollar.vaults.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.vaults.v1.MsgSetPausedStateResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.vaults.v1.MsgSetPausedStateResponse".into()
    }
}
include!("noble.dollar.vaults.v1.serde.rs");
include!("noble.dollar.vaults.v1.tonic.rs");
// @@protoc_insertion_point(module)
