// @generated
// This file is @generated by prost-build.
/// Delivered is the event emitted when a vaa is successfully delivered.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Delivered {
    #[prost(bytes = "vec", tag = "1")]
    pub vaa: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for Delivered {
    const NAME: &'static str = "Delivered";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.Delivered".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.Delivered".into()
    }
}
/// MTokenReceived is the event emitted when M tokens are received on Noble.
///
/// <https://github.com/m0-foundation/m-portal/blob/682481178808005a160e41d5318242c1abc2f88f/src/Portal.sol#L382-L382>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MTokenReceived {
    #[prost(uint32, tag = "1")]
    pub source_chain_id: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub destination_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub recipient: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub amount: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub index: i64,
    #[prost(bytes = "vec", tag = "7")]
    pub message_id: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MTokenReceived {
    const NAME: &'static str = "MTokenReceived";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MTokenReceived".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MTokenReceived".into()
    }
}
/// TransferRedeemed is an event emitted when a transfer has been redeemed.
///
/// <https://github.com/m0-foundation/m-portal/blob/682481178808005a160e41d5318242c1abc2f88f/src/Portal.sol#L384-L385>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferRedeemed {
    #[prost(bytes = "vec", tag = "1")]
    pub digest: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for TransferRedeemed {
    const NAME: &'static str = "TransferRedeemed";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.TransferRedeemed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.TransferRedeemed".into()
    }
}
/// USDNTokenSent is an event emitted after transferring USDN tokens via Wormhole.
///
/// <https://github.com/m0-foundation/m-portal/blob/682481178808005a160e41d5318242c1abc2f88f/src/Portal.sol#L240-L249>
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsdnTokenSent {
    #[prost(string, tag = "1")]
    pub source_token: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub destination_chain_id: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub destination_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub sender: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "6")]
    pub amount: ::prost::alloc::string::String,
    #[prost(int64, tag = "7")]
    pub index: i64,
    #[prost(bytes = "vec", tag = "8")]
    pub message_id: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for UsdnTokenSent {
    const NAME: &'static str = "USDNTokenSent";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.USDNTokenSent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.USDNTokenSent".into()
    }
}
/// PeerUpdated is an event emitted whenever a peer is updated.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PeerUpdated {
    #[prost(uint32, tag = "1")]
    pub chain: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub old_transceiver: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub new_transceiver: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub old_manager: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub new_manager: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for PeerUpdated {
    const NAME: &'static str = "PeerUpdated";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.PeerUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.PeerUpdated".into()
    }
}
/// BridgingPathSet is an event emitted whenever a supported bridging path is set.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BridgingPathSet {
    #[prost(uint32, tag = "1")]
    pub destination_chain_id: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub destination_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "3")]
    pub supported: bool,
}
impl ::prost::Name for BridgingPathSet {
    const NAME: &'static str = "BridgingPathSet";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.BridgingPathSet".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.BridgingPathSet".into()
    }
}
/// OwnershipTransferred is an event emitted whenever an ownership transfer occurs.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnershipTransferred {
    #[prost(string, tag = "1")]
    pub previous_owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for OwnershipTransferred {
    const NAME: &'static str = "OwnershipTransferred";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.OwnershipTransferred".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.OwnershipTransferred".into()
    }
}
/// Paused is an event emitted when the portal pause
/// state is changed to paused.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Paused {}
impl ::prost::Name for Paused {
    const NAME: &'static str = "Paused";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.Paused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.Paused".into()
    }
}
/// Unpaused is an event emitted when the portal pause
/// state is changed to unpaused.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Unpaused {}
impl ::prost::Name for Unpaused {
    const NAME: &'static str = "Unpaused";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.Unpaused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.Unpaused".into()
    }
}
/// Peer is the type that stores information about a peer.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Peer {
    #[prost(bytes = "vec", tag = "1")]
    pub transceiver: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub manager: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for Peer {
    const NAME: &'static str = "Peer";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.Peer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.Peer".into()
    }
}
/// BridgingPath is the type that stores information about a supported bridging path.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BridgingPath {
    #[prost(uint32, tag = "1")]
    pub destination_chain_id: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub destination_token: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for BridgingPath {
    const NAME: &'static str = "BridgingPath";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.BridgingPath".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.BridgingPath".into()
    }
}
/// GenesisState defines the genesis state of the Noble Dollar Portal submodule.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// owner is the account that controls the Noble Dollar Portal.
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    /// paused contains the genesis paused state of the Noble Dollar Portal.
    #[prost(bool, tag = "2")]
    pub paused: bool,
    /// peers contains the genesis peers of the Noble Dollar Portal.
    #[prost(map = "uint32, message", tag = "3")]
    pub peers: ::std::collections::HashMap<u32, Peer>,
    /// bridging_paths contains the genesis supported bridging paths of the Noble Dollar Portal.
    #[prost(message, repeated, tag = "4")]
    pub bridging_paths: ::prost::alloc::vec::Vec<BridgingPath>,
    /// nonce contains the next available nonce used for transfers out of the Noble Dollar Portal.
    #[prost(uint32, tag = "5")]
    pub nonce: u32,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.GenesisState".into()
    }
}
/// MsgDeliverInjection is an internal message type used for delivering Noble
/// Dollar Portal messages. It is specifically used to insert VAA's into the top
/// of a block via ABCI++.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDeliverInjection {
    #[prost(bytes = "vec", tag = "1")]
    pub vaa: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgDeliverInjection {
    const NAME: &'static str = "MsgDeliverInjection";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgDeliverInjection".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgDeliverInjection".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryOwner {}
impl ::prost::Name for QueryOwner {
    const NAME: &'static str = "QueryOwner";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryOwner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryOwner".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryOwnerResponse {
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryOwnerResponse {
    const NAME: &'static str = "QueryOwnerResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryOwnerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryOwnerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPaused {}
impl ::prost::Name for QueryPaused {
    const NAME: &'static str = "QueryPaused";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryPaused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryPaused".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPausedResponse {
    #[prost(bool, tag = "1")]
    pub paused: bool,
}
impl ::prost::Name for QueryPausedResponse {
    const NAME: &'static str = "QueryPausedResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryPausedResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryPausedResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryPeers {}
impl ::prost::Name for QueryPeers {
    const NAME: &'static str = "QueryPeers";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryPeers".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryPeers".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryPeersResponse {
    #[prost(map = "uint32, message", tag = "1")]
    pub peers: ::std::collections::HashMap<u32, Peer>,
}
impl ::prost::Name for QueryPeersResponse {
    const NAME: &'static str = "QueryPeersResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryPeersResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryPeersResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryDestinationTokens {
    #[prost(uint32, tag = "1")]
    pub chain_id: u32,
}
impl ::prost::Name for QueryDestinationTokens {
    const NAME: &'static str = "QueryDestinationTokens";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryDestinationTokens".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryDestinationTokens".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDestinationTokensResponse {
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub destination_tokens: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
impl ::prost::Name for QueryDestinationTokensResponse {
    const NAME: &'static str = "QueryDestinationTokensResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryDestinationTokensResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryDestinationTokensResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryNonce {}
impl ::prost::Name for QueryNonce {
    const NAME: &'static str = "QueryNonce";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryNonce".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryNonce".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryNonceResponse {
    #[prost(uint32, tag = "1")]
    pub nonce: u32,
}
impl ::prost::Name for QueryNonceResponse {
    const NAME: &'static str = "QueryNonceResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.QueryNonceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.QueryNonceResponse".into()
    }
}
/// MsgDeliver is the entrypoint for delivering Noble Dollar Portal messages.
/// This is the public message to enable permissionless manual relaying, and
/// MsgDeliverInjection is an internal message used only by validators.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDeliver {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub vaa: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgDeliver {
    const NAME: &'static str = "MsgDeliver";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgDeliver".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgDeliver".into()
    }
}
/// MsgDeliverResponse is the response of the Deliver message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgDeliverResponse {}
impl ::prost::Name for MsgDeliverResponse {
    const NAME: &'static str = "MsgDeliverResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgDeliverResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgDeliverResponse".into()
    }
}
/// MsgTransfer is the entrypoint for transferring the Noble Dollar cross-chain.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTransfer {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub destination_chain_id: u32,
    #[prost(bytes = "vec", tag = "4")]
    pub destination_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub recipient: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgTransfer {
    const NAME: &'static str = "MsgTransfer";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgTransfer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgTransfer".into()
    }
}
/// MsgTransferResponse is the response of the Transfer message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgTransferResponse {}
impl ::prost::Name for MsgTransferResponse {
    const NAME: &'static str = "MsgTransferResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgTransferResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgTransferResponse".into()
    }
}
/// MsgSetPausedState allows the authority to configure the Noble Dollar Portal paused state.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetPausedState {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub paused: bool,
}
impl ::prost::Name for MsgSetPausedState {
    const NAME: &'static str = "MsgSetPausedState";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgSetPausedState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgSetPausedState".into()
    }
}
/// MsgSetPausedStateResponse is the response of the SetPausedState message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetPausedStateResponse {}
impl ::prost::Name for MsgSetPausedStateResponse {
    const NAME: &'static str = "MsgSetPausedStateResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgSetPausedStateResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgSetPausedStateResponse".into()
    }
}
/// MsgSetPeer allows the Noble Dollar Portal owner to set external peers.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetPeer {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub chain: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub transceiver: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub manager: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgSetPeer {
    const NAME: &'static str = "MsgSetPeer";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgSetPeer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgSetPeer".into()
    }
}
/// MsgSetPeerResponse is the response of the SetPeer message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetPeerResponse {}
impl ::prost::Name for MsgSetPeerResponse {
    const NAME: &'static str = "MsgSetPeerResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgSetPeerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgSetPeerResponse".into()
    }
}
/// MsgSetBridgingPath allows the Noble Dollar Portal owner to set supported bridging paths.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetBridgingPath {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub destination_chain_id: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub destination_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub supported: bool,
}
impl ::prost::Name for MsgSetBridgingPath {
    const NAME: &'static str = "MsgSetBridgingPath";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgSetBridgingPath".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgSetBridgingPath".into()
    }
}
/// MsgSetBridgingPathResponse is the response of the SetBridgingPath message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetBridgingPathResponse {}
impl ::prost::Name for MsgSetBridgingPathResponse {
    const NAME: &'static str = "MsgSetBridgingPathResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgSetBridgingPathResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgSetBridgingPathResponse".into()
    }
}
/// MsgTransferOwnership allows the Noble Dollar Portal ownership to be transferred.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTransferOwnership {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgTransferOwnership {
    const NAME: &'static str = "MsgTransferOwnership";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgTransferOwnership".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgTransferOwnership".into()
    }
}
/// MsgTransferOwnershipResponse is the response of the TransferOwnership message.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgTransferOwnershipResponse {}
impl ::prost::Name for MsgTransferOwnershipResponse {
    const NAME: &'static str = "MsgTransferOwnershipResponse";
    const PACKAGE: &'static str = "noble.dollar.portal.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.dollar.portal.v1.MsgTransferOwnershipResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.dollar.portal.v1.MsgTransferOwnershipResponse".into()
    }
}
include!("noble.dollar.portal.v1.serde.rs");
include!("noble.dollar.portal.v1.tonic.rs");
// @@protoc_insertion_point(module)
