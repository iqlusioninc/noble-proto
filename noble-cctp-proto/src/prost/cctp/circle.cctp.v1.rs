// @generated
// This file is @generated by prost-build.
/// *
/// A public key used to verify message signatures
/// @param attester ECDSA uncompressed public key, hex encoded
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Attester {
    #[prost(string, tag = "1")]
    pub attester: ::prost::alloc::string::String,
}
impl ::prost::Name for Attester {
    const NAME: &'static str = "Attester";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.Attester".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.Attester".into()
    }
}
/// *
/// Message format for BurnMessages
/// @param version the message body version
/// @param burn_token the burn token address on source domain as bytes32
/// @param mint_recipient the mint recipient address as bytes32
/// @param amount the burn amount
/// @param message_sender the message sender
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BurnMessage {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub burn_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub mint_recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub amount: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub message_sender: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for BurnMessage {
    const NAME: &'static str = "BurnMessage";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.BurnMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.BurnMessage".into()
    }
}
/// *
/// Message format for BurningAndMintingPaused
/// @param paused true if paused, false if not paused
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BurningAndMintingPaused {
    #[prost(bool, tag = "1")]
    pub paused: bool,
}
impl ::prost::Name for BurningAndMintingPaused {
    const NAME: &'static str = "BurningAndMintingPaused";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.BurningAndMintingPaused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.BurningAndMintingPaused".into()
    }
}
// *
// Event signatures in the CCTP module

/// *
/// Emitted when an attester is enabled
/// @param attester newly enabled attester
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttesterEnabled {
    #[prost(string, tag = "1")]
    pub attester: ::prost::alloc::string::String,
}
impl ::prost::Name for AttesterEnabled {
    const NAME: &'static str = "AttesterEnabled";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.AttesterEnabled".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.AttesterEnabled".into()
    }
}
/// *
/// Emitted when an attester is disabled
/// @param attester newly disabled attester
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttesterDisabled {
    #[prost(string, tag = "1")]
    pub attester: ::prost::alloc::string::String,
}
impl ::prost::Name for AttesterDisabled {
    const NAME: &'static str = "AttesterDisabled";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.AttesterDisabled".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.AttesterDisabled".into()
    }
}
/// *
/// Emitted when threshold number of attestations (m in m/n multisig) is updated
/// @param old_signature_threshold old signature threshold
/// @param new_signature_threshold new signature threshold
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignatureThresholdUpdated {
    #[prost(uint64, tag = "1")]
    pub old_signature_threshold: u64,
    #[prost(uint64, tag = "2")]
    pub new_signature_threshold: u64,
}
impl ::prost::Name for SignatureThresholdUpdated {
    const NAME: &'static str = "SignatureThresholdUpdated";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.SignatureThresholdUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.SignatureThresholdUpdated".into()
    }
}
/// *
/// Emitted when owner address is updated
/// @param previous_owner representing the address of the previous owner
/// @param new_owner representing the address of the new owner
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnerUpdated {
    #[prost(string, tag = "1")]
    pub previous_owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for OwnerUpdated {
    const NAME: &'static str = "OwnerUpdated";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.OwnerUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.OwnerUpdated".into()
    }
}
/// *
/// Emitted when starting the two stage transfer ownership process
/// @param previousOwner representing the address of the previous owner
/// @param newOwner representing the address of the new owner
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OwnershipTransferStarted {
    #[prost(string, tag = "1")]
    pub previous_owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for OwnershipTransferStarted {
    const NAME: &'static str = "OwnershipTransferStarted";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.OwnershipTransferStarted".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.OwnershipTransferStarted".into()
    }
}
/// *
/// Emitted when pauser address is updated
/// @param previous_pauser representing the address of the previous pauser
/// @param new_pauser representing the address of the new pauser
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauserUpdated {
    #[prost(string, tag = "1")]
    pub previous_pauser: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_pauser: ::prost::alloc::string::String,
}
impl ::prost::Name for PauserUpdated {
    const NAME: &'static str = "PauserUpdated";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.PauserUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.PauserUpdated".into()
    }
}
/// *
/// Emitted when attester manager address is updated
/// @param previous_attester_manager representing the address of the previous
/// attester manager
/// @param new_attester_manager representing the address of the new attester
/// manager
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttesterManagerUpdated {
    #[prost(string, tag = "1")]
    pub previous_attester_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_attester_manager: ::prost::alloc::string::String,
}
impl ::prost::Name for AttesterManagerUpdated {
    const NAME: &'static str = "AttesterManagerUpdated";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.AttesterManagerUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.AttesterManagerUpdated".into()
    }
}
/// *
/// Emitted when token controller address is updated
/// @param previous_token_controller representing the address of the previous
/// token controller
/// @param new_token_controller representing the address of the new token
/// controller
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenControllerUpdated {
    #[prost(string, tag = "1")]
    pub previous_token_controller: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_token_controller: ::prost::alloc::string::String,
}
impl ::prost::Name for TokenControllerUpdated {
    const NAME: &'static str = "TokenControllerUpdated";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.TokenControllerUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.TokenControllerUpdated".into()
    }
}
/// *
/// Emitted when burning and minting tokens is paused
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BurningAndMintingPausedEvent {}
impl ::prost::Name for BurningAndMintingPausedEvent {
    const NAME: &'static str = "BurningAndMintingPausedEvent";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.BurningAndMintingPausedEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.BurningAndMintingPausedEvent".into()
    }
}
/// *
/// Emitted when burning and minting tokens is unpaused
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BurningAndMintingUnpausedEvent {}
impl ::prost::Name for BurningAndMintingUnpausedEvent {
    const NAME: &'static str = "BurningAndMintingUnpausedEvent";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.BurningAndMintingUnpausedEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.BurningAndMintingUnpausedEvent".into()
    }
}
/// *
/// Emitted when sending and receiving messages is paused
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendingAndReceivingPausedEvent {}
impl ::prost::Name for SendingAndReceivingPausedEvent {
    const NAME: &'static str = "SendingAndReceivingPausedEvent";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.SendingAndReceivingPausedEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.SendingAndReceivingPausedEvent".into()
    }
}
/// *
/// Emitted when sending and receiving messages is paused
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendingAndReceivingUnpausedEvent {}
impl ::prost::Name for SendingAndReceivingUnpausedEvent {
    const NAME: &'static str = "SendingAndReceivingUnpausedEvent";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.SendingAndReceivingUnpausedEvent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.SendingAndReceivingUnpausedEvent".into()
    }
}
/// *
/// Emitted when a DepositForBurn message is sent
/// @param nonce unique nonce reserved by message
/// @param burn_token address of token burnt on source domain
/// @param amount deposit amount
/// @param depositor address where deposit is transferred from
/// @param mint_recipient address receiving minted tokens on destination domain
/// as bytes32
/// @param destination_domain destination domain
/// @param destination_token_messenger address of TokenMessenger on destination
/// domain as bytes32
/// @param destination_caller authorized caller as bytes32 of receiveMessage() on
/// destination domain, if not equal to bytes32(0). If equal to bytes32(0), any
/// address can call receiveMessage().
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DepositForBurn {
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
    #[prost(string, tag = "2")]
    pub burn_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub depositor: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub mint_recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "6")]
    pub destination_domain: u32,
    #[prost(bytes = "vec", tag = "7")]
    pub destination_token_messenger: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub destination_caller: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for DepositForBurn {
    const NAME: &'static str = "DepositForBurn";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.DepositForBurn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.DepositForBurn".into()
    }
}
/// *
/// Emitted when tokens are minted
/// @param mint_recipient recipient address of minted tokens
/// @param amount amount of minted tokens
/// @param mint_token contract address of minted token
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MintAndWithdraw {
    #[prost(bytes = "vec", tag = "1")]
    pub mint_recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub mint_token: ::prost::alloc::string::String,
}
impl ::prost::Name for MintAndWithdraw {
    const NAME: &'static str = "MintAndWithdraw";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MintAndWithdraw".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MintAndWithdraw".into()
    }
}
/// *
/// Emitted when a token pair is linked
/// @param local_token local token to support
/// @param remote_domain remote domain
/// @param remote_token token on `remoteDomain` corresponding to `localToken`
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenPairLinked {
    #[prost(string, tag = "1")]
    pub local_token: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub remote_domain: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub remote_token: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for TokenPairLinked {
    const NAME: &'static str = "TokenPairLinked";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.TokenPairLinked".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.TokenPairLinked".into()
    }
}
/// *
/// Emitted when a token pair is unlinked
/// @param local_token local token address
/// @param remote_domain remote domain
/// @param remote_token token on `remoteDomain` unlinked from `localToken`
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenPairUnlinked {
    #[prost(string, tag = "1")]
    pub local_token: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub remote_domain: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub remote_token: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for TokenPairUnlinked {
    const NAME: &'static str = "TokenPairUnlinked";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.TokenPairUnlinked".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.TokenPairUnlinked".into()
    }
}
/// *
/// Emitted when a new message is dispatched
/// @param message Raw bytes of message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageSent {
    #[prost(bytes = "vec", tag = "1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MessageSent {
    const NAME: &'static str = "MessageSent";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MessageSent".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MessageSent".into()
    }
}
/// *
/// Emitted when a new message is received
/// @param caller caller (msg.sender) on destination domain
/// @param source_domain the source domain this message originated from
/// @param nonce the nonce unique to this message
/// @param sender the sender of this message
/// @param message_body message body bytes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageReceived {
    #[prost(string, tag = "1")]
    pub caller: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub source_domain: u32,
    #[prost(uint64, tag = "3")]
    pub nonce: u64,
    #[prost(bytes = "vec", tag = "4")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub message_body: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MessageReceived {
    const NAME: &'static str = "MessageReceived";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MessageReceived".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MessageReceived".into()
    }
}
/// *
/// Emitted when max message body size is updated
/// @param new_max_message_body_size new maximum message body size, in bytes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaxMessageBodySizeUpdated {
    #[prost(uint64, tag = "1")]
    pub new_max_message_body_size: u64,
}
impl ::prost::Name for MaxMessageBodySizeUpdated {
    const NAME: &'static str = "MaxMessageBodySizeUpdated";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MaxMessageBodySizeUpdated".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MaxMessageBodySizeUpdated".into()
    }
}
/// *
/// Emitted when a RemoteTokenMessenger is added
/// @param domain remote domain
/// @param remote_token_messenger RemoteTokenMessenger on domain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteTokenMessengerAdded {
    #[prost(uint32, tag = "1")]
    pub domain: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub remote_token_messenger: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for RemoteTokenMessengerAdded {
    const NAME: &'static str = "RemoteTokenMessengerAdded";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.RemoteTokenMessengerAdded".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.RemoteTokenMessengerAdded".into()
    }
}
/// *
/// Emitted when a RemoteTokenMessenger is removed
/// @param domain remote domain
/// @param remote_token_messenger RemoteTokenMessenger on domain
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteTokenMessengerRemoved {
    #[prost(uint32, tag = "1")]
    pub domain: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub remote_token_messenger: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for RemoteTokenMessengerRemoved {
    const NAME: &'static str = "RemoteTokenMessengerRemoved";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.RemoteTokenMessengerRemoved".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.RemoteTokenMessengerRemoved".into()
    }
}
/// *
/// Emitted when max burn amount per message is updated
/// @param local_token
/// @param old_amount old max burn amount
/// @param new_amount new max burn amount
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBurnLimitPerMessage {
    #[prost(string, tag = "1")]
    pub token: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub burn_limit_per_message: ::prost::alloc::string::String,
}
impl ::prost::Name for SetBurnLimitPerMessage {
    const NAME: &'static str = "SetBurnLimitPerMessage";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.SetBurnLimitPerMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.SetBurnLimitPerMessage".into()
    }
}
/// *
/// Message format for BurningAndMintingPaused
/// @param paused true if paused, false if not paused
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MaxMessageBodySize {
    #[prost(uint64, tag = "1")]
    pub amount: u64,
}
impl ::prost::Name for MaxMessageBodySize {
    const NAME: &'static str = "MaxMessageBodySize";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MaxMessageBodySize".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MaxMessageBodySize".into()
    }
}
/// *
/// The Nonce type functions both to mark receipt of received messages and a
/// counter for sending messages
/// @param source_domain the domain id, used to mark used nonces for received
/// messages
/// @param nonce the nonce number
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Nonce {
    #[prost(uint32, tag = "1")]
    pub source_domain: u32,
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
}
impl ::prost::Name for Nonce {
    const NAME: &'static str = "Nonce";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.Nonce".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.Nonce".into()
    }
}
/// *
/// PerMessageBurnLimit is the maximum amount of a certain denom that can be
/// burned in an single burn
/// @param denom the denom
/// @param amount the amount that can be burned (in microunits).  An amount of
/// 1000000 uusdc is equivalent to 1USDC
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerMessageBurnLimit {
    #[prost(string, tag = "1")]
    pub denom: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
}
impl ::prost::Name for PerMessageBurnLimit {
    const NAME: &'static str = "PerMessageBurnLimit";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.PerMessageBurnLimit".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.PerMessageBurnLimit".into()
    }
}
/// *
/// @param domain_id
/// @param address
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoteTokenMessenger {
    #[prost(uint32, tag = "1")]
    pub domain_id: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for RemoteTokenMessenger {
    const NAME: &'static str = "RemoteTokenMessenger";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.RemoteTokenMessenger".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.RemoteTokenMessenger".into()
    }
}
/// *
/// Message format for SendingAndReceivingMessagesPaused
/// @param paused true if paused, false if not paused
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendingAndReceivingMessagesPaused {
    #[prost(bool, tag = "1")]
    pub paused: bool,
}
impl ::prost::Name for SendingAndReceivingMessagesPaused {
    const NAME: &'static str = "SendingAndReceivingMessagesPaused";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.SendingAndReceivingMessagesPaused".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.SendingAndReceivingMessagesPaused".into()
    }
}
/// *
/// SignatureThreshold is the minimum amount of signatures required to attest to
/// a message (the 'm' in a m/n multisig)
/// @param amount the number of signatures required
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SignatureThreshold {
    #[prost(uint32, tag = "1")]
    pub amount: u32,
}
impl ::prost::Name for SignatureThreshold {
    const NAME: &'static str = "SignatureThreshold";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.SignatureThreshold".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.SignatureThreshold".into()
    }
}
/// *
/// TokenPair is used to look up the Noble token (i.e. "uusdc") from a remote
/// domain token address Multiple remote_domain + remote_token pairs can map to
/// the same local_token
///
/// @param remote_domain the remote domain_id corresponding to the token
/// @param remote_token the remote token address
/// @param local_token the corresponding Noble token denom in uunits
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenPair {
    #[prost(uint32, tag = "1")]
    pub remote_domain: u32,
    #[prost(bytes = "vec", tag = "2")]
    pub remote_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "3")]
    pub local_token: ::prost::alloc::string::String,
}
impl ::prost::Name for TokenPair {
    const NAME: &'static str = "TokenPair";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.TokenPair".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.TokenPair".into()
    }
}
/// GenesisState defines the cctp module's genesis state.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    #[prost(string, tag = "2")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub attester_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub pauser: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub token_controller: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub attester_list: ::prost::alloc::vec::Vec<Attester>,
    #[prost(message, repeated, tag = "7")]
    pub per_message_burn_limit_list: ::prost::alloc::vec::Vec<PerMessageBurnLimit>,
    #[prost(message, optional, tag = "8")]
    pub burning_and_minting_paused: ::core::option::Option<BurningAndMintingPaused>,
    #[prost(message, optional, tag = "9")]
    pub sending_and_receiving_messages_paused:
        ::core::option::Option<SendingAndReceivingMessagesPaused>,
    #[prost(message, optional, tag = "10")]
    pub max_message_body_size: ::core::option::Option<MaxMessageBodySize>,
    #[prost(message, optional, tag = "11")]
    pub next_available_nonce: ::core::option::Option<Nonce>,
    #[prost(message, optional, tag = "12")]
    pub signature_threshold: ::core::option::Option<SignatureThreshold>,
    #[prost(message, repeated, tag = "13")]
    pub token_pair_list: ::prost::alloc::vec::Vec<TokenPair>,
    #[prost(message, repeated, tag = "14")]
    pub used_nonces_list: ::prost::alloc::vec::Vec<Nonce>,
    #[prost(message, repeated, tag = "15")]
    pub token_messenger_list: ::prost::alloc::vec::Vec<RemoteTokenMessenger>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.GenesisState".into()
    }
}
/// *
/// Generic message header for all messages passing through CCTP
/// The message body is dynamically-sized to support custom message body
/// formats. Other fields must be fixed-size to avoid hash collisions.
///
/// Padding: uintNN fields are left-padded, and bytesNN fields are right-padded.
///
/// @param version the version of the message format
/// @param source_domain domain of home chain
/// @param destination_domain domain of destination chain
/// @param nonce destination-specific nonce
/// @param sender address of sender on source chain as bytes32
/// @param recipient address of recipient on destination chain as bytes32
/// @param destination_caller address of caller on destination chain as bytes32
/// @param message_body raw bytes of message body
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Message {
    #[prost(uint32, tag = "1")]
    pub version: u32,
    #[prost(uint32, tag = "2")]
    pub source_domain: u32,
    #[prost(uint32, tag = "3")]
    pub destination_domain: u32,
    #[prost(uint64, tag = "4")]
    pub nonce: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub sender: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "7")]
    pub destination_caller: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub message_body: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for Message {
    const NAME: &'static str = "Message";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.Message".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.Message".into()
    }
}
/// QueryRolesRequest is the request type for the Query/Roles RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryRolesRequest {}
impl ::prost::Name for QueryRolesRequest {
    const NAME: &'static str = "QueryRolesRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryRolesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryRolesRequest".into()
    }
}
/// QueryRolesResponse is the response type for the Query/Roles RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRolesResponse {
    #[prost(string, tag = "1")]
    pub owner: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub attester_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub pauser: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub token_controller: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryRolesResponse {
    const NAME: &'static str = "QueryRolesResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryRolesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryRolesResponse".into()
    }
}
/// QueryAttestersRequest is the request type for the Query/Attester RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAttesterRequest {
    #[prost(string, tag = "1")]
    pub attester: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryGetAttesterRequest {
    const NAME: &'static str = "QueryGetAttesterRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetAttesterRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetAttesterRequest".into()
    }
}
/// QueryAttestersResponse is the response type for the Query/Attester RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetAttesterResponse {
    #[prost(message, optional, tag = "1")]
    pub attester: ::core::option::Option<Attester>,
}
impl ::prost::Name for QueryGetAttesterResponse {
    const NAME: &'static str = "QueryGetAttesterResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetAttesterResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetAttesterResponse".into()
    }
}
/// QueryAllAttestersRequest is the request type for the Query/Attesters RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllAttestersRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryAllAttestersRequest {
    const NAME: &'static str = "QueryAllAttestersRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryAllAttestersRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryAllAttestersRequest".into()
    }
}
/// QueryAllAttestersResponse is the response type for the Query/Attesters RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllAttestersResponse {
    #[prost(message, repeated, tag = "1")]
    pub attesters: ::prost::alloc::vec::Vec<Attester>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryAllAttestersResponse {
    const NAME: &'static str = "QueryAllAttestersResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryAllAttestersResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryAllAttestersResponse".into()
    }
}
/// QueryPerMessageBurnLimitRequest is the request type for the
/// Query/PerMessageBurnLimit RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetPerMessageBurnLimitRequest {
    #[prost(string, tag = "1")]
    pub denom: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryGetPerMessageBurnLimitRequest {
    const NAME: &'static str = "QueryGetPerMessageBurnLimitRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetPerMessageBurnLimitRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetPerMessageBurnLimitRequest".into()
    }
}
/// QueryPerMessageBurnLimitResponse is the response type for the
/// Query/PerMessageBurnLimit RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetPerMessageBurnLimitResponse {
    #[prost(message, optional, tag = "1")]
    pub burn_limit: ::core::option::Option<PerMessageBurnLimit>,
}
impl ::prost::Name for QueryGetPerMessageBurnLimitResponse {
    const NAME: &'static str = "QueryGetPerMessageBurnLimitResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetPerMessageBurnLimitResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetPerMessageBurnLimitResponse".into()
    }
}
/// QueryAllPerMessageBurnLimitsRequest is the response type for the
/// Query/PerMessageBurnLimit RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllPerMessageBurnLimitsRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryAllPerMessageBurnLimitsRequest {
    const NAME: &'static str = "QueryAllPerMessageBurnLimitsRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryAllPerMessageBurnLimitsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryAllPerMessageBurnLimitsRequest".into()
    }
}
/// QueryAllPerMessageBurnLimitsRequest is the response type for the
/// Query/PerMessageBurnLimit RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllPerMessageBurnLimitsResponse {
    #[prost(message, repeated, tag = "1")]
    pub burn_limits: ::prost::alloc::vec::Vec<PerMessageBurnLimit>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryAllPerMessageBurnLimitsResponse {
    const NAME: &'static str = "QueryAllPerMessageBurnLimitsResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryAllPerMessageBurnLimitsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryAllPerMessageBurnLimitsResponse".into()
    }
}
/// QueryBurningAndMintingPausedRequest is the request type for the
/// Query/BurningAndMintingPaused RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetBurningAndMintingPausedRequest {}
impl ::prost::Name for QueryGetBurningAndMintingPausedRequest {
    const NAME: &'static str = "QueryGetBurningAndMintingPausedRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetBurningAndMintingPausedRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetBurningAndMintingPausedRequest".into()
    }
}
/// QueryBurningAndMintingPausedResponse is the response type for the
/// Query/BurningAndMintingPaused RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetBurningAndMintingPausedResponse {
    #[prost(message, optional, tag = "1")]
    pub paused: ::core::option::Option<BurningAndMintingPaused>,
}
impl ::prost::Name for QueryGetBurningAndMintingPausedResponse {
    const NAME: &'static str = "QueryGetBurningAndMintingPausedResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetBurningAndMintingPausedResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetBurningAndMintingPausedResponse".into()
    }
}
/// QuerySendingAndReceivingPausedRequest is the request type for the
/// Query/SendingAndReceivingPaused RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetSendingAndReceivingMessagesPausedRequest {}
impl ::prost::Name for QueryGetSendingAndReceivingMessagesPausedRequest {
    const NAME: &'static str = "QueryGetSendingAndReceivingMessagesPausedRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetSendingAndReceivingMessagesPausedRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetSendingAndReceivingMessagesPausedRequest".into()
    }
}
/// QuerySendingAndReceivingPausedResponse is the response type for the
/// Query/SendingAndReceivingPaused RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetSendingAndReceivingMessagesPausedResponse {
    #[prost(message, optional, tag = "1")]
    pub paused: ::core::option::Option<SendingAndReceivingMessagesPaused>,
}
impl ::prost::Name for QueryGetSendingAndReceivingMessagesPausedResponse {
    const NAME: &'static str = "QueryGetSendingAndReceivingMessagesPausedResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetSendingAndReceivingMessagesPausedResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetSendingAndReceivingMessagesPausedResponse".into()
    }
}
/// QueryMaxMessageBodySizeRequest is the request type for the
/// Query/MaxMessageBodySize RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetMaxMessageBodySizeRequest {}
impl ::prost::Name for QueryGetMaxMessageBodySizeRequest {
    const NAME: &'static str = "QueryGetMaxMessageBodySizeRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetMaxMessageBodySizeRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetMaxMessageBodySizeRequest".into()
    }
}
/// QueryMaxMessageBodySizeResponse is the response type for the
/// Query/MaxMessageBodySize RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetMaxMessageBodySizeResponse {
    #[prost(message, optional, tag = "1")]
    pub amount: ::core::option::Option<MaxMessageBodySize>,
}
impl ::prost::Name for QueryGetMaxMessageBodySizeResponse {
    const NAME: &'static str = "QueryGetMaxMessageBodySizeResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetMaxMessageBodySizeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetMaxMessageBodySizeResponse".into()
    }
}
/// QueryGetNextAvailableNonceRequest is the request type for the
/// Query/NextAvailableNonce RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetNextAvailableNonceRequest {}
impl ::prost::Name for QueryGetNextAvailableNonceRequest {
    const NAME: &'static str = "QueryGetNextAvailableNonceRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetNextAvailableNonceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetNextAvailableNonceRequest".into()
    }
}
/// Query QueryGetNextAvailableNonceResponse is the response type for the
/// Query/NextAvailableNonce RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetNextAvailableNonceResponse {
    #[prost(message, optional, tag = "1")]
    pub nonce: ::core::option::Option<Nonce>,
}
impl ::prost::Name for QueryGetNextAvailableNonceResponse {
    const NAME: &'static str = "QueryGetNextAvailableNonceResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetNextAvailableNonceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetNextAvailableNonceResponse".into()
    }
}
/// QuerySignatureThresholdRequest is the request type for the
/// Query/SignatureThreshold RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetSignatureThresholdRequest {}
impl ::prost::Name for QueryGetSignatureThresholdRequest {
    const NAME: &'static str = "QueryGetSignatureThresholdRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetSignatureThresholdRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetSignatureThresholdRequest".into()
    }
}
/// QuerySignatureThresholdResponse is the response type for the
/// Query/SignatureThreshold RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetSignatureThresholdResponse {
    #[prost(message, optional, tag = "1")]
    pub amount: ::core::option::Option<SignatureThreshold>,
}
impl ::prost::Name for QueryGetSignatureThresholdResponse {
    const NAME: &'static str = "QueryGetSignatureThresholdResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetSignatureThresholdResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetSignatureThresholdResponse".into()
    }
}
/// QueryGetTokenPairRequest is the request type for the Query/TokenPair RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetTokenPairRequest {
    #[prost(uint32, tag = "1")]
    pub remote_domain: u32,
    #[prost(string, tag = "2")]
    pub remote_token: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryGetTokenPairRequest {
    const NAME: &'static str = "QueryGetTokenPairRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetTokenPairRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetTokenPairRequest".into()
    }
}
/// QueryGetTokenPairResponse is the response type for the Query/TokenPair RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetTokenPairResponse {
    #[prost(message, optional, tag = "1")]
    pub pair: ::core::option::Option<TokenPair>,
}
impl ::prost::Name for QueryGetTokenPairResponse {
    const NAME: &'static str = "QueryGetTokenPairResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetTokenPairResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetTokenPairResponse".into()
    }
}
/// QueryAllTokenPairsRequest is the request type for the Query/TokenPairs RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllTokenPairsRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryAllTokenPairsRequest {
    const NAME: &'static str = "QueryAllTokenPairsRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryAllTokenPairsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryAllTokenPairsRequest".into()
    }
}
/// QueryAllTokenPairsResponse is the response type for the Query/TokenPairs RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllTokenPairsResponse {
    #[prost(message, repeated, tag = "1")]
    pub token_pairs: ::prost::alloc::vec::Vec<TokenPair>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryAllTokenPairsResponse {
    const NAME: &'static str = "QueryAllTokenPairsResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryAllTokenPairsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryAllTokenPairsResponse".into()
    }
}
/// QueryGetUsedNonceRequest is the request type for the Query/UsedNonce RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetUsedNonceRequest {
    #[prost(uint32, tag = "1")]
    pub source_domain: u32,
    #[prost(uint64, tag = "2")]
    pub nonce: u64,
}
impl ::prost::Name for QueryGetUsedNonceRequest {
    const NAME: &'static str = "QueryGetUsedNonceRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetUsedNonceRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetUsedNonceRequest".into()
    }
}
/// QueryGetUsedNonceResponse is the response type for the Query/UsedNonce RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryGetUsedNonceResponse {
    #[prost(message, optional, tag = "1")]
    pub nonce: ::core::option::Option<Nonce>,
}
impl ::prost::Name for QueryGetUsedNonceResponse {
    const NAME: &'static str = "QueryGetUsedNonceResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryGetUsedNonceResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryGetUsedNonceResponse".into()
    }
}
/// QueryAllUsedNonceRequest is the request type for the Query/UsedNonces RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllUsedNoncesRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryAllUsedNoncesRequest {
    const NAME: &'static str = "QueryAllUsedNoncesRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryAllUsedNoncesRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryAllUsedNoncesRequest".into()
    }
}
/// QueryAllUsedNonceResponse is the response type for the Query/UsedNonces RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllUsedNoncesResponse {
    #[prost(message, repeated, tag = "1")]
    pub used_nonces: ::prost::alloc::vec::Vec<Nonce>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryAllUsedNoncesResponse {
    const NAME: &'static str = "QueryAllUsedNoncesResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryAllUsedNoncesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryAllUsedNoncesResponse".into()
    }
}
/// QueryRemoteTokenMessengerRequest is the request type for the
/// Query/RemoteTokenMessenger RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryRemoteTokenMessengerRequest {
    #[prost(uint32, tag = "1")]
    pub domain_id: u32,
}
impl ::prost::Name for QueryRemoteTokenMessengerRequest {
    const NAME: &'static str = "QueryRemoteTokenMessengerRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryRemoteTokenMessengerRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryRemoteTokenMessengerRequest".into()
    }
}
/// QueryRemoteTokenMessengerResponse is the response type for the
/// Query/RemoteTokenMessenger RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRemoteTokenMessengerResponse {
    #[prost(message, optional, tag = "1")]
    pub remote_token_messenger: ::core::option::Option<RemoteTokenMessenger>,
}
impl ::prost::Name for QueryRemoteTokenMessengerResponse {
    const NAME: &'static str = "QueryRemoteTokenMessengerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryRemoteTokenMessengerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryRemoteTokenMessengerResponse".into()
    }
}
/// QueryRemoteTokenMessengersRequest is the request type for the
/// Query/RemoteTokenMessengers RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRemoteTokenMessengersRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageRequest>,
}
impl ::prost::Name for QueryRemoteTokenMessengersRequest {
    const NAME: &'static str = "QueryRemoteTokenMessengersRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryRemoteTokenMessengersRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryRemoteTokenMessengersRequest".into()
    }
}
/// QueryRemoteTokenMessengersResponse is the response type for the
/// Query/RemoteTokenMessengers RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRemoteTokenMessengersResponse {
    #[prost(message, repeated, tag = "1")]
    pub remote_token_messengers: ::prost::alloc::vec::Vec<RemoteTokenMessenger>,
    #[prost(message, optional, tag = "2")]
    pub pagination:
        ::core::option::Option<cosmos_sdk_proto::cosmos::base::query::v1beta1::PageResponse>,
}
impl ::prost::Name for QueryRemoteTokenMessengersResponse {
    const NAME: &'static str = "QueryRemoteTokenMessengersResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryRemoteTokenMessengersResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryRemoteTokenMessengersResponse".into()
    }
}
/// QueryBurnMessageVersionRequest is the request type for the
/// Query/BurnMessageVersion RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryBurnMessageVersionRequest {}
impl ::prost::Name for QueryBurnMessageVersionRequest {
    const NAME: &'static str = "QueryBurnMessageVersionRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryBurnMessageVersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryBurnMessageVersionRequest".into()
    }
}
/// QueryBurnMessageVersionResponse is the response type for the
/// Query/BurnMessageVersion RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryBurnMessageVersionResponse {
    /// version is the burn message version of the local domain.
    #[prost(uint32, tag = "1")]
    pub version: u32,
}
impl ::prost::Name for QueryBurnMessageVersionResponse {
    const NAME: &'static str = "QueryBurnMessageVersionResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryBurnMessageVersionResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryBurnMessageVersionResponse".into()
    }
}
/// QueryLocalMessageVersionRequest is the request type for the
/// Query/LocalMessageVersion RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLocalMessageVersionRequest {}
impl ::prost::Name for QueryLocalMessageVersionRequest {
    const NAME: &'static str = "QueryLocalMessageVersionRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryLocalMessageVersionRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryLocalMessageVersionRequest".into()
    }
}
/// QueryLocalMessageVersionResponse is the response type for the
/// Query/LocalMessageVersion RPC method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLocalMessageVersionResponse {
    /// version is the message version of the local domain.
    #[prost(uint32, tag = "1")]
    pub version: u32,
}
impl ::prost::Name for QueryLocalMessageVersionResponse {
    const NAME: &'static str = "QueryLocalMessageVersionResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryLocalMessageVersionResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryLocalMessageVersionResponse".into()
    }
}
/// QueryLocalDomainRequest is the request type for the Query/LocalDomain RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLocalDomainRequest {}
impl ::prost::Name for QueryLocalDomainRequest {
    const NAME: &'static str = "QueryLocalDomainRequest";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryLocalDomainRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryLocalDomainRequest".into()
    }
}
/// QueryLocalDomainResponse is the response type for the Query/LocalDomain RPC
/// method.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryLocalDomainResponse {
    /// domain_id is the id of the local domain.
    #[prost(uint32, tag = "1")]
    pub domain_id: u32,
}
impl ::prost::Name for QueryLocalDomainResponse {
    const NAME: &'static str = "QueryLocalDomainResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.QueryLocalDomainResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.QueryLocalDomainResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateOwner {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_owner: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUpdateOwner {
    const NAME: &'static str = "MsgUpdateOwner";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateOwner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateOwner".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateOwnerResponse {}
impl ::prost::Name for MsgUpdateOwnerResponse {
    const NAME: &'static str = "MsgUpdateOwnerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateOwnerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateOwnerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateAttesterManager {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_attester_manager: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUpdateAttesterManager {
    const NAME: &'static str = "MsgUpdateAttesterManager";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateAttesterManager".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateAttesterManager".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateAttesterManagerResponse {}
impl ::prost::Name for MsgUpdateAttesterManagerResponse {
    const NAME: &'static str = "MsgUpdateAttesterManagerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateAttesterManagerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateAttesterManagerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateTokenController {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_token_controller: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUpdateTokenController {
    const NAME: &'static str = "MsgUpdateTokenController";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateTokenController".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateTokenController".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateTokenControllerResponse {}
impl ::prost::Name for MsgUpdateTokenControllerResponse {
    const NAME: &'static str = "MsgUpdateTokenControllerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateTokenControllerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateTokenControllerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdatePauser {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub new_pauser: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUpdatePauser {
    const NAME: &'static str = "MsgUpdatePauser";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdatePauser".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdatePauser".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdatePauserResponse {}
impl ::prost::Name for MsgUpdatePauserResponse {
    const NAME: &'static str = "MsgUpdatePauserResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdatePauserResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdatePauserResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAcceptOwner {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgAcceptOwner {
    const NAME: &'static str = "MsgAcceptOwner";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgAcceptOwner".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgAcceptOwner".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAcceptOwnerResponse {}
impl ::prost::Name for MsgAcceptOwnerResponse {
    const NAME: &'static str = "MsgAcceptOwnerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgAcceptOwnerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgAcceptOwnerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgEnableAttester {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub attester: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgEnableAttester {
    const NAME: &'static str = "MsgEnableAttester";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgEnableAttester".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgEnableAttester".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgEnableAttesterResponse {}
impl ::prost::Name for MsgEnableAttesterResponse {
    const NAME: &'static str = "MsgEnableAttesterResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgEnableAttesterResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgEnableAttesterResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDisableAttester {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub attester: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgDisableAttester {
    const NAME: &'static str = "MsgDisableAttester";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgDisableAttester".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgDisableAttester".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgDisableAttesterResponse {}
impl ::prost::Name for MsgDisableAttesterResponse {
    const NAME: &'static str = "MsgDisableAttesterResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgDisableAttesterResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgDisableAttesterResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgPauseBurningAndMinting {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgPauseBurningAndMinting {
    const NAME: &'static str = "MsgPauseBurningAndMinting";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgPauseBurningAndMinting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgPauseBurningAndMinting".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgPauseBurningAndMintingResponse {}
impl ::prost::Name for MsgPauseBurningAndMintingResponse {
    const NAME: &'static str = "MsgPauseBurningAndMintingResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgPauseBurningAndMintingResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgPauseBurningAndMintingResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUnpauseBurningAndMinting {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUnpauseBurningAndMinting {
    const NAME: &'static str = "MsgUnpauseBurningAndMinting";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUnpauseBurningAndMinting".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUnpauseBurningAndMinting".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUnpauseBurningAndMintingResponse {}
impl ::prost::Name for MsgUnpauseBurningAndMintingResponse {
    const NAME: &'static str = "MsgUnpauseBurningAndMintingResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUnpauseBurningAndMintingResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUnpauseBurningAndMintingResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgPauseSendingAndReceivingMessages {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgPauseSendingAndReceivingMessages {
    const NAME: &'static str = "MsgPauseSendingAndReceivingMessages";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgPauseSendingAndReceivingMessages".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgPauseSendingAndReceivingMessages".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgPauseSendingAndReceivingMessagesResponse {}
impl ::prost::Name for MsgPauseSendingAndReceivingMessagesResponse {
    const NAME: &'static str = "MsgPauseSendingAndReceivingMessagesResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgPauseSendingAndReceivingMessagesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgPauseSendingAndReceivingMessagesResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUnpauseSendingAndReceivingMessages {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUnpauseSendingAndReceivingMessages {
    const NAME: &'static str = "MsgUnpauseSendingAndReceivingMessages";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUnpauseSendingAndReceivingMessages".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUnpauseSendingAndReceivingMessages".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUnpauseSendingAndReceivingMessagesResponse {}
impl ::prost::Name for MsgUnpauseSendingAndReceivingMessagesResponse {
    const NAME: &'static str = "MsgUnpauseSendingAndReceivingMessagesResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUnpauseSendingAndReceivingMessagesResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUnpauseSendingAndReceivingMessagesResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateMaxMessageBodySize {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub message_size: u64,
}
impl ::prost::Name for MsgUpdateMaxMessageBodySize {
    const NAME: &'static str = "MsgUpdateMaxMessageBodySize";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateMaxMessageBodySize".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateMaxMessageBodySize".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateMaxMessageBodySizeResponse {}
impl ::prost::Name for MsgUpdateMaxMessageBodySizeResponse {
    const NAME: &'static str = "MsgUpdateMaxMessageBodySizeResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateMaxMessageBodySizeResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateMaxMessageBodySizeResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetMaxBurnAmountPerMessage {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub local_token: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgSetMaxBurnAmountPerMessage {
    const NAME: &'static str = "MsgSetMaxBurnAmountPerMessage";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgSetMaxBurnAmountPerMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgSetMaxBurnAmountPerMessage".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetMaxBurnAmountPerMessageResponse {}
impl ::prost::Name for MsgSetMaxBurnAmountPerMessageResponse {
    const NAME: &'static str = "MsgSetMaxBurnAmountPerMessageResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgSetMaxBurnAmountPerMessageResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgSetMaxBurnAmountPerMessageResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDepositForBurn {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub destination_domain: u32,
    #[prost(bytes = "vec", tag = "4")]
    pub mint_recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub burn_token: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgDepositForBurn {
    const NAME: &'static str = "MsgDepositForBurn";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgDepositForBurn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgDepositForBurn".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgDepositForBurnResponse {
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
impl ::prost::Name for MsgDepositForBurnResponse {
    const NAME: &'static str = "MsgDepositForBurnResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgDepositForBurnResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgDepositForBurnResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDepositForBurnWithCaller {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub amount: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub destination_domain: u32,
    #[prost(bytes = "vec", tag = "4")]
    pub mint_recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub burn_token: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "6")]
    pub destination_caller: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgDepositForBurnWithCaller {
    const NAME: &'static str = "MsgDepositForBurnWithCaller";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgDepositForBurnWithCaller".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgDepositForBurnWithCaller".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgDepositForBurnWithCallerResponse {
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
impl ::prost::Name for MsgDepositForBurnWithCallerResponse {
    const NAME: &'static str = "MsgDepositForBurnWithCallerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgDepositForBurnWithCallerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgDepositForBurnWithCallerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgReplaceDepositForBurn {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub original_message: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub original_attestation: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub new_destination_caller: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub new_mint_recipient: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgReplaceDepositForBurn {
    const NAME: &'static str = "MsgReplaceDepositForBurn";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgReplaceDepositForBurn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgReplaceDepositForBurn".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgReplaceDepositForBurnResponse {}
impl ::prost::Name for MsgReplaceDepositForBurnResponse {
    const NAME: &'static str = "MsgReplaceDepositForBurnResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgReplaceDepositForBurnResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgReplaceDepositForBurnResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgReceiveMessage {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub attestation: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgReceiveMessage {
    const NAME: &'static str = "MsgReceiveMessage";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgReceiveMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgReceiveMessage".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgReceiveMessageResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
impl ::prost::Name for MsgReceiveMessageResponse {
    const NAME: &'static str = "MsgReceiveMessageResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgReceiveMessageResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgReceiveMessageResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSendMessage {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub destination_domain: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub message_body: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgSendMessage {
    const NAME: &'static str = "MsgSendMessage";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgSendMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgSendMessage".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSendMessageResponse {
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
impl ::prost::Name for MsgSendMessageResponse {
    const NAME: &'static str = "MsgSendMessageResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgSendMessageResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgSendMessageResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSendMessageWithCaller {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub destination_domain: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub recipient: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub message_body: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub destination_caller: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgSendMessageWithCaller {
    const NAME: &'static str = "MsgSendMessageWithCaller";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgSendMessageWithCaller".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgSendMessageWithCaller".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSendMessageWithCallerResponse {
    #[prost(uint64, tag = "1")]
    pub nonce: u64,
}
impl ::prost::Name for MsgSendMessageWithCallerResponse {
    const NAME: &'static str = "MsgSendMessageWithCallerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgSendMessageWithCallerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgSendMessageWithCallerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgReplaceMessage {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub original_message: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub original_attestation: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub new_message_body: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub new_destination_caller: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgReplaceMessage {
    const NAME: &'static str = "MsgReplaceMessage";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgReplaceMessage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgReplaceMessage".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgReplaceMessageResponse {}
impl ::prost::Name for MsgReplaceMessageResponse {
    const NAME: &'static str = "MsgReplaceMessageResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgReplaceMessageResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgReplaceMessageResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateSignatureThreshold {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub amount: u32,
}
impl ::prost::Name for MsgUpdateSignatureThreshold {
    const NAME: &'static str = "MsgUpdateSignatureThreshold";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateSignatureThreshold".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateSignatureThreshold".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateSignatureThresholdResponse {}
impl ::prost::Name for MsgUpdateSignatureThresholdResponse {
    const NAME: &'static str = "MsgUpdateSignatureThresholdResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUpdateSignatureThresholdResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUpdateSignatureThresholdResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgLinkTokenPair {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub remote_domain: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub remote_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub local_token: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgLinkTokenPair {
    const NAME: &'static str = "MsgLinkTokenPair";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgLinkTokenPair".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgLinkTokenPair".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgLinkTokenPairResponse {}
impl ::prost::Name for MsgLinkTokenPairResponse {
    const NAME: &'static str = "MsgLinkTokenPairResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgLinkTokenPairResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgLinkTokenPairResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUnlinkTokenPair {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub remote_domain: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub remote_token: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "4")]
    pub local_token: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUnlinkTokenPair {
    const NAME: &'static str = "MsgUnlinkTokenPair";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUnlinkTokenPair".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUnlinkTokenPair".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUnlinkTokenPairResponse {}
impl ::prost::Name for MsgUnlinkTokenPairResponse {
    const NAME: &'static str = "MsgUnlinkTokenPairResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgUnlinkTokenPairResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgUnlinkTokenPairResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgAddRemoteTokenMessenger {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub domain_id: u32,
    #[prost(bytes = "vec", tag = "3")]
    pub address: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgAddRemoteTokenMessenger {
    const NAME: &'static str = "MsgAddRemoteTokenMessenger";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgAddRemoteTokenMessenger".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgAddRemoteTokenMessenger".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgAddRemoteTokenMessengerResponse {}
impl ::prost::Name for MsgAddRemoteTokenMessengerResponse {
    const NAME: &'static str = "MsgAddRemoteTokenMessengerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgAddRemoteTokenMessengerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgAddRemoteTokenMessengerResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRemoveRemoteTokenMessenger {
    #[prost(string, tag = "1")]
    pub from: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub domain_id: u32,
}
impl ::prost::Name for MsgRemoveRemoteTokenMessenger {
    const NAME: &'static str = "MsgRemoveRemoteTokenMessenger";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgRemoveRemoteTokenMessenger".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgRemoveRemoteTokenMessenger".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgRemoveRemoteTokenMessengerResponse {}
impl ::prost::Name for MsgRemoveRemoteTokenMessengerResponse {
    const NAME: &'static str = "MsgRemoveRemoteTokenMessengerResponse";
    const PACKAGE: &'static str = "circle.cctp.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "circle.cctp.v1.MsgRemoveRemoteTokenMessengerResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/circle.cctp.v1.MsgRemoveRemoteTokenMessengerResponse".into()
    }
}
include!("circle.cctp.v1.serde.rs");
include!("circle.cctp.v1.tonic.rs");
// @@protoc_insertion_point(module)
