// @generated
// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingAccount {
    #[prost(message, optional, tag = "1")]
    pub base_account: ::core::option::Option<cosmos_sdk_proto::cosmos::auth::v1beta1::BaseAccount>,
    #[prost(string, tag = "2")]
    pub channel: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub recipient: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub created_at: i64,
    #[prost(string, tag = "5")]
    pub fallback: ::prost::alloc::string::String,
}
impl ::prost::Name for ForwardingAccount {
    const NAME: &'static str = "ForwardingAccount";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.ForwardingAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.ForwardingAccount".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingPubKey {
    #[prost(bytes = "vec", tag = "1")]
    pub key: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for ForwardingPubKey {
    const NAME: &'static str = "ForwardingPubKey";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.ForwardingPubKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.ForwardingPubKey".into()
    }
}
/// AccountRegistered is emitted whenever a new forwarding account is registered.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountRegistered {
    /// address is the address of the forwarding account.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// channel is the channel id that funds are forwarded through.
    #[prost(string, tag = "2")]
    pub channel: ::prost::alloc::string::String,
    /// recipient is the address of the recipient of forwards.
    #[prost(string, tag = "3")]
    pub recipient: ::prost::alloc::string::String,
    /// fallback is the address of the fallback account.
    #[prost(string, tag = "4")]
    pub fallback: ::prost::alloc::string::String,
}
impl ::prost::Name for AccountRegistered {
    const NAME: &'static str = "AccountRegistered";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.AccountRegistered".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.AccountRegistered".into()
    }
}
/// AccountCleared is emitted whenever a forwarding account is cleared.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountCleared {
    /// address is the address of the forwarding account.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// recipient is the address of the fallback account.
    #[prost(string, tag = "2")]
    pub recipient: ::prost::alloc::string::String,
}
impl ::prost::Name for AccountCleared {
    const NAME: &'static str = "AccountCleared";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.AccountCleared".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.AccountCleared".into()
    }
}
/// AllowedDenomsConfigured is emitted whenever the allowed denoms are updated.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllowedDenomsConfigured {
    /// previous_denoms is the list of previously allowed denoms.
    #[prost(string, repeated, tag = "1")]
    pub previous_denoms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// current_denoms is the list of currently allowed denoms.
    #[prost(string, repeated, tag = "2")]
    pub current_denoms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for AllowedDenomsConfigured {
    const NAME: &'static str = "AllowedDenomsConfigured";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.AllowedDenomsConfigured".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.AllowedDenomsConfigured".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    #[prost(string, repeated, tag = "1")]
    pub allowed_denoms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, uint64", tag = "2")]
    pub num_of_accounts: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
    #[prost(map = "string, uint64", tag = "3")]
    pub num_of_forwards: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
    #[prost(map = "string, string", tag = "4")]
    pub total_forwarded:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.GenesisState".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterAccountData {
    #[prost(string, tag = "1")]
    pub recipient: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub channel: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub fallback: ::prost::alloc::string::String,
}
impl ::prost::Name for RegisterAccountData {
    const NAME: &'static str = "RegisterAccountData";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.RegisterAccountData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.RegisterAccountData".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterAccountMemo {
    #[prost(message, optional, tag = "1")]
    pub noble: ::core::option::Option<register_account_memo::RegisterAccountDataWrapper>,
}
/// Nested message and enum types in `RegisterAccountMemo`.
pub mod register_account_memo {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RegisterAccountDataWrapper {
        #[prost(message, optional, tag = "1")]
        pub forwarding: ::core::option::Option<super::RegisterAccountData>,
    }
    impl ::prost::Name for RegisterAccountDataWrapper {
        const NAME: &'static str = "RegisterAccountDataWrapper";
        const PACKAGE: &'static str = "noble.forwarding.v1";
        fn full_name() -> ::prost::alloc::string::String {
            "noble.forwarding.v1.RegisterAccountMemo.RegisterAccountDataWrapper".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/noble.forwarding.v1.RegisterAccountMemo.RegisterAccountDataWrapper".into()
        }
    }
}
impl ::prost::Name for RegisterAccountMemo {
    const NAME: &'static str = "RegisterAccountMemo";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.RegisterAccountMemo".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.RegisterAccountMemo".into()
    }
}
//

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryDenoms {}
impl ::prost::Name for QueryDenoms {
    const NAME: &'static str = "QueryDenoms";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.QueryDenoms".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.QueryDenoms".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryDenomsResponse {
    #[prost(string, repeated, tag = "1")]
    pub allowed_denoms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for QueryDenomsResponse {
    const NAME: &'static str = "QueryDenomsResponse";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.QueryDenomsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.QueryDenomsResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAddress {
    #[prost(string, tag = "1")]
    pub channel: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub recipient: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub fallback: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryAddress {
    const NAME: &'static str = "QueryAddress";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.QueryAddress".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.QueryAddress".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAddressResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub exists: bool,
}
impl ::prost::Name for QueryAddressResponse {
    const NAME: &'static str = "QueryAddressResponse";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.QueryAddressResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.QueryAddressResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryStats {}
impl ::prost::Name for QueryStats {
    const NAME: &'static str = "QueryStats";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.QueryStats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.QueryStats".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStatsResponse {
    #[prost(map = "string, message", tag = "1")]
    pub stats: ::std::collections::HashMap<::prost::alloc::string::String, Stats>,
}
impl ::prost::Name for QueryStatsResponse {
    const NAME: &'static str = "QueryStatsResponse";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.QueryStatsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.QueryStatsResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStatsByChannel {
    #[prost(string, tag = "1")]
    pub channel: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryStatsByChannel {
    const NAME: &'static str = "QueryStatsByChannel";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.QueryStatsByChannel".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.QueryStatsByChannel".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryStatsByChannelResponse {
    #[prost(uint64, tag = "1")]
    pub num_of_accounts: u64,
    #[prost(uint64, tag = "2")]
    pub num_of_forwards: u64,
    #[prost(message, repeated, tag = "3")]
    pub total_forwarded: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for QueryStatsByChannelResponse {
    const NAME: &'static str = "QueryStatsByChannelResponse";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.QueryStatsByChannelResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.QueryStatsByChannelResponse".into()
    }
}
//

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Stats {
    #[prost(string, tag = "1")]
    pub chain_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub num_of_accounts: u64,
    #[prost(uint64, tag = "3")]
    pub num_of_forwards: u64,
    #[prost(message, repeated, tag = "4")]
    pub total_forwarded: ::prost::alloc::vec::Vec<cosmos_sdk_proto::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for Stats {
    const NAME: &'static str = "Stats";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.Stats".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.Stats".into()
    }
}
//

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRegisterAccount {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub recipient: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub channel: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub fallback: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRegisterAccount {
    const NAME: &'static str = "MsgRegisterAccount";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.MsgRegisterAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.MsgRegisterAccount".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRegisterAccountResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRegisterAccountResponse {
    const NAME: &'static str = "MsgRegisterAccountResponse";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.MsgRegisterAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.MsgRegisterAccountResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClearAccount {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub address: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub fallback: bool,
}
impl ::prost::Name for MsgClearAccount {
    const NAME: &'static str = "MsgClearAccount";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.MsgClearAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.MsgClearAccount".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgClearAccountResponse {}
impl ::prost::Name for MsgClearAccountResponse {
    const NAME: &'static str = "MsgClearAccountResponse";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.MsgClearAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.MsgClearAccountResponse".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgSetAllowedDenoms {
    #[prost(string, tag = "1")]
    pub signer: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub denoms: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for MsgSetAllowedDenoms {
    const NAME: &'static str = "MsgSetAllowedDenoms";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.MsgSetAllowedDenoms".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.MsgSetAllowedDenoms".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgSetAllowedDenomsResponse {}
impl ::prost::Name for MsgSetAllowedDenomsResponse {
    const NAME: &'static str = "MsgSetAllowedDenomsResponse";
    const PACKAGE: &'static str = "noble.forwarding.v1";
    fn full_name() -> ::prost::alloc::string::String {
        "noble.forwarding.v1.MsgSetAllowedDenomsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/noble.forwarding.v1.MsgSetAllowedDenomsResponse".into()
    }
}
include!("noble.forwarding.v1.serde.rs");
include!("noble.forwarding.v1.tonic.rs");
// @@protoc_insertion_point(module)
